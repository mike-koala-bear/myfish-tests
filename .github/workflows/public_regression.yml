name: External Engine Regression
run-name: >
  External Engine Regression${{ inputs.job_id && format(' (job {0})', inputs.job_id) || '' }}

on:
  workflow_dispatch:
    inputs:
      use_private_repo:
        description: "Clone the private engine repo with a PAT (otherwise use local binaries)"
        type: boolean
        required: true
        default: true
      private_repo:
        description: "owner/name of the private engine repository"
        required: true
        default: "mike/myfish"
      engine_a_ref:
        description: "Git ref (branch, tag, or SHA) for Engine A (test build)"
        required: true
        default: "main"
      engine_b_ref:
        description: "Git ref for Engine B baseline"
        required: true
        default: "main"
      match_options:
        description: "Comma-separated key=value pairs for games, concurrency, max_moves"
        required: true
        default: "games=1000,concurrency=16,max_moves=512"
      time_control:
        description: "Time control as base+increment seconds (e.g. 0.8+0.08)"
        required: true
        default: "0.8+0.08"
      engine_threads:
        description: "Threads option passed to both engines"
        required: true
        default: "1"
      engine_paths:
        description: "Comma-separated paths (workspace_binary,local_engine_a,local_engine_b)"
        required: true
        default: "workspace_binary=build/myfish,local_engine_a=engines/engine-a,local_engine_b=engines/engine-b"
      labels:
        description: "Comma-separated labels for engines (engine_a,engine_b)"
        required: true
        default: "engine_a=workspace,engine_b=baseline"
      job_id:
        description: "Optional external job identifier"
        required: false
        default: ""

permissions:
  contents: read

jobs:
  regression:
    runs-on: ubuntu-latest
    timeout-minutes: 720
    env:
      RESULTS_DIR: ${{ github.workspace }}/regression-results
    steps:
      - name: Checkout harness repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Determine harness root
        run: |
          if [[ "${{ inputs.use_private_repo }}" == "true" ]]; then
            echo "HARNESS_ROOT=${{ github.workspace }}/engine-src" >> "$GITHUB_ENV"
          else
            echo "HARNESS_ROOT=${{ github.workspace }}" >> "$GITHUB_ENV"
          fi
          echo "RESULTS_DIR=${{ github.workspace }}/regression-results" >> "$GITHUB_ENV"

      - name: Parse workflow inputs
        env:
          MATCH_OPTIONS_RAW: ${{ inputs.match_options }}
          TIME_CONTROL_RAW: ${{ inputs.time_control }}
          ENGINE_PATHS_RAW: ${{ inputs.engine_paths }}
          ENGINE_LABELS_RAW: ${{ inputs.labels }}
        run: |
          python - <<'PY'
          import os

          def parse_pairs(text):
              data = {}
              for part in text.split(','):
                  part = part.strip()
                  if not part:
                      continue
                  if '=' not in part:
                      raise SystemExit(f"Invalid key=value pair: {part}")
                  key, value = part.split('=', 1)
                  data[key.strip()] = value.strip()
              return data

          match_opts = parse_pairs(os.environ.get('MATCH_OPTIONS_RAW', ''))
          paths = parse_pairs(os.environ.get('ENGINE_PATHS_RAW', ''))
          labels = parse_pairs(os.environ.get('ENGINE_LABELS_RAW', ''))

          def as_int(data, key, default):
              try:
                  return int(data.get(key, default))
              except ValueError:
                  raise SystemExit(f"{key} must be an integer")

          games = as_int(match_opts, 'games', 1000)
          concurrency = as_int(match_opts, 'concurrency', 16)
          max_moves = as_int(match_opts, 'max_moves', 512)

          workspace_binary = paths.get('workspace_binary', 'build/myfish')
          local_engine_a = paths.get('local_engine_a', 'engines/engine-a')
          local_engine_b = paths.get('local_engine_b', 'engines/engine-b')

          engine_a_label = labels.get('engine_a', 'workspace')
          engine_b_label = labels.get('engine_b', 'baseline')

          time_raw = os.environ.get('TIME_CONTROL_RAW', '0.8+0.08').strip() or '0.8+0.08'
          if '+' in time_raw:
              base_str, inc_str = time_raw.split('+', 1)
          else:
              base_str, inc_str = time_raw, '0'
          try:
              time_base = float(base_str)
              time_increment = float(inc_str)
          except ValueError:
              raise SystemExit('time_control must be formatted as number or number+increment')

          env_path = os.environ['GITHUB_ENV']
          with open(env_path, 'a', encoding='utf-8') as fh:
              fh.write(f"MATCH_GAMES={games}\n")
              fh.write(f"MATCH_CONCURRENCY={concurrency}\n")
              fh.write(f"MATCH_MAX_MOVES={max_moves}\n")
              fh.write(f"TIME_PER_MOVE={time_base}\n")
              fh.write(f"TIME_INCREMENT={time_increment}\n")
              fh.write(f"WORKSPACE_BINARY={workspace_binary}\n")
              fh.write(f"LOCAL_ENGINE_A_BIN={local_engine_a}\n")
              fh.write(f"LOCAL_ENGINE_B_BIN={local_engine_b}\n")
              fh.write(f"ENGINE_A_LABEL={engine_a_label}\n")
              fh.write(f"ENGINE_B_LABEL={engine_b_label}\n")
          PY
          echo "ENGINE_THREADS=${{ inputs.engine_threads }}" >> "$GITHUB_ENV"

      - name: Clone private engine repository
        if: ${{ inputs.use_private_repo }}
        env:
          PAT: ${{ secrets.MYFISH_PAT }}
        run: |
          if [[ -z "${PAT}" ]]; then
            echo "::error ::Missing MYFISH_PAT secret with repo access"
            exit 1
          fi

          rm -rf "$HARNESS_ROOT"
          git config --global --add safe.directory "$HARNESS_ROOT" || true
          git clone --filter=blob:none --no-tags \
            "https://x-access-token:${PAT}@github.com/${{ inputs.private_repo }}.git" \
            "$HARNESS_ROOT"

          cd "$HARNESS_ROOT"
          git fetch origin "${{ inputs.engine_a_ref }}" || true
          git checkout -B regression-workspace "${{ inputs.engine_a_ref }}"
          git submodule update --init --recursive

          git fetch origin "${{ inputs.engine_b_ref }}" || true
          if git rev-parse --verify --quiet "${{ inputs.engine_b_ref }}" >/dev/null; then
            BASELINE_SHA=$(git rev-parse "${{ inputs.engine_b_ref }}")
          elif git rev-parse --verify --quiet "origin/${{ inputs.engine_b_ref }}" >/dev/null; then
            BASELINE_SHA=$(git rev-parse "origin/${{ inputs.engine_b_ref }}")
          else
            git fetch origin "${{ inputs.engine_b_ref }}"
            BASELINE_SHA=$(git rev-parse FETCH_HEAD)
          fi
          WORKSPACE_SHA=$(git rev-parse HEAD)
          echo "BASELINE_SHA=${BASELINE_SHA}" >> "$GITHUB_ENV"
          echo "WORKSPACE_SHA=${WORKSPACE_SHA}" >> "$GITHUB_ENV"

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          if [[ -f "$HARNESS_ROOT/requirements.txt" ]]; then
            pip install -r "$HARNESS_ROOT/requirements.txt"
          else
            pip install python-chess
          fi

      - name: Configure & build Engine A (workspace)
        if: ${{ inputs.use_private_repo }}
        working-directory: ${{ env.HARNESS_ROOT }}
        run: |
          cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
          cmake --build build -j"$(nproc)"
          ENGINE_A_BIN="${HARNESS_ROOT}/${WORKSPACE_BINARY}"
          if [[ ! -f "$ENGINE_A_BIN" ]]; then
            echo "::error ::Engine A binary not found at $ENGINE_A_BIN"
            exit 1
          fi
          chmod +x "$ENGINE_A_BIN"
          echo "ENGINE_A_BIN=$ENGINE_A_BIN" >> "$GITHUB_ENV"

      - name: Use provided engine binaries
        if: ${{ !inputs.use_private_repo }}
        run: |
          ENGINE_A_BIN="${GITHUB_WORKSPACE}/${LOCAL_ENGINE_A_BIN}"
          ENGINE_B_BIN="${GITHUB_WORKSPACE}/${LOCAL_ENGINE_B_BIN}"
          if [[ ! -f "$ENGINE_A_BIN" ]]; then
            echo "::error ::Engine A binary missing at $ENGINE_A_BIN"
            exit 1
          fi
          if [[ ! -f "$ENGINE_B_BIN" ]]; then
            echo "::error ::Engine B binary missing at $ENGINE_B_BIN"
            exit 1
          fi
          chmod +x "$ENGINE_A_BIN" "$ENGINE_B_BIN"
          echo "ENGINE_A_BIN=$ENGINE_A_BIN" >> "$GITHUB_ENV"
          echo "ENGINE_B_BIN=$ENGINE_B_BIN" >> "$GITHUB_ENV"

      - name: Run regression (private repo mode)
        id: regression_private
        if: ${{ inputs.use_private_repo }}
        working-directory: ${{ env.HARNESS_ROOT }}
        env:
          RESULTS_DIR: ${{ env.RESULTS_DIR }}
        run: |
          mkdir -p "$RESULTS_DIR"
          python tools/regression_client.py fixed \
            --games "${MATCH_GAMES}" \
            --concurrency "${MATCH_CONCURRENCY}" \
            --max-moves "${MATCH_MAX_MOVES}" \
            --time "${TIME_PER_MOVE}" \
            --increment "${TIME_INCREMENT}" \
            --engineA "--threads ${ENGINE_THREADS}" \
            --engineA-name "${ENGINE_A_LABEL}" \
            --engineA-workspace \
            --engineA-workspace-binary "${ENGINE_A_BIN}" \
            --engineB "--threads ${ENGINE_THREADS}" \
            --engineB-name "${ENGINE_B_LABEL}" \
            --engineB-git-ref "${BASELINE_SHA}" \
            --engineB-git-binary "${WORKSPACE_BINARY}" \
            --engineB-git-rebuild \
            --json-out "$RESULTS_DIR/summary.json"

      - name: Run regression (local binary mode)
        id: regression_local
        if: ${{ !inputs.use_private_repo }}
        working-directory: ${{ env.HARNESS_ROOT }}
        env:
          RESULTS_DIR: ${{ env.RESULTS_DIR }}
        run: |
          mkdir -p "$RESULTS_DIR"
          python tools/regression_client.py fixed \
            --games "${MATCH_GAMES}" \
            --concurrency "${MATCH_CONCURRENCY}" \
            --max-moves "${MATCH_MAX_MOVES}" \
            --time "${TIME_PER_MOVE}" \
            --increment "${TIME_INCREMENT}" \
            --engineA "--threads ${ENGINE_THREADS}" \
            --engineA-name "${ENGINE_A_LABEL}" \
            --engineA-workspace \
            --engineA-workspace-binary "${ENGINE_A_BIN}" \
            --engineB "--threads ${ENGINE_THREADS}" \
            --engineB-name "${ENGINE_B_LABEL}" \
            --engineB-workspace \
            --engineB-workspace-binary "${ENGINE_B_BIN}" \
            --json-out "$RESULTS_DIR/summary.json"

      - name: Show summary
        if: always()
        run: |
          if [[ -f "${RESULTS_DIR}/summary.json" ]]; then
            cat "${RESULTS_DIR}/summary.json"
          else
            echo "summary.json not produced"
          fi

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: regression-results-${{ inputs.job_id || github.run_id }}
          path: ${{ env.RESULTS_DIR }}
          if-no-files-found: error
